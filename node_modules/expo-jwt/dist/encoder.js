'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _encBase = require('crypto-js/enc-base64');

var _encBase2 = _interopRequireDefault(_encBase);

var _encUtf = require('crypto-js/enc-utf8');

var _encUtf2 = _interopRequireDefault(_encUtf);

var _errors = require('./errors');

var _algorithms = require('./algorithms');

var _algorithms2 = _interopRequireDefault(_algorithms);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultOptions = {
  algorithm: 'HS256'
};

var _key = void 0;

var Encoder = function () {
  function Encoder(body, key) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Encoder);

    this.body = body;
    this.options = _extends({}, defaultOptions, options);
    _key = key;
  }

  _createClass(Encoder, [{
    key: 'buildHeader',
    value: function buildHeader() {
      return {
        alg: this.options.algorithm,
        typ: 'JWT'
      };
    }
  }, {
    key: 'encodeAndSign',
    value: function encodeAndSign() {
      var jsonHeader = JSON.stringify(this.buildHeader());
      var jsonBody = JSON.stringify(this.body);

      var base64Header = _encBase2.default.stringify(_encUtf2.default.parse(jsonHeader));
      var base64Body = _encBase2.default.stringify(_encUtf2.default.parse(jsonBody));

      var encodedHeader = (0, _helpers.urlEncodeBase64)(base64Header);
      var encodedBody = (0, _helpers.urlEncodeBase64)(base64Body);

      if (this.options.algorithm === 'none') {
        return encodedHeader + '.' + encodedBody + '.';
      }

      var algorithm = _algorithms2.default[this.options.algorithm];

      if (!algorithm) {
        throw new _errors.AlgorithmNotSupported();
      }

      var signature = algorithm(encodedHeader + '.' + encodedBody, _key);
      var encodedSignature = signature.toString(_encBase2.default);
      var urlSafeEncodedSignature = (0, _helpers.urlEncodeBase64)(encodedSignature);

      return encodedHeader + '.' + encodedBody + '.' + urlSafeEncodedSignature;
    }
  }]);

  return Encoder;
}();

exports.default = Encoder;